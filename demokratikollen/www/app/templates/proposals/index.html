{% extends "proposals/base.html" %}

{% block styles -%}{{ super() }}
    <style>
.canvas {
}

.node rect {
    stroke: none;
}
rect.node-group {
  display:none;
}
.flow {
  fill: #000;
  fill-opacity: .2;
  stroke: 0px;
  stroke-opacity: .2;
}

.node-group-label path {
  fill: none;
  stroke-width: 3px;
  stroke: #777;
}
.node-group-label text {
  font-size: 12px;
  cursor: default;
}
.click-capture {
  pointer-events: all;
}
    </style>



<style>
.d3-tip {
  line-height: 1;
  font-weight: bold;
  padding: 10px;
  background: rgba(0,0,0, 0.5);
  color: #fff;
  border-radius: 2px;
  pointer-events: none;
}

/* Creates a small triangle extender for the tooltip */
.d3-tip:after {
  box-sizing: border-box;
  display: inline;
  font-size: 10px;
  width: 100%;
  line-height: 1;
  color: rgba(0, 0, 0, 0.5);
  position: absolute;
  pointer-events: none;
}

/* Northward tooltips */
.d3-tip.n:after {
  content: "\25BC";
  margin: -1px 0 0 0;
  top: 100%;
  left: 0;
  text-align: center;
}

/* Eastward tooltips */
.d3-tip.e:after {
  content: "\25C0";
  margin: -4px 0 0 0;
  top: 50%;
  left: -8px;
}

/* Southward tooltips */
.d3-tip.s:after {
  content: "\25B2";
  margin: 0 0 1px 0;
  top: -8px;
  left: 0;
  text-align: center;
}

/* Westward tooltips */
.d3-tip.w:after {
  content: "\25B6";
  margin: -4px 0 0 -1px;
  top: 50%;
  left: 100%;
}

</style>
{%- endblock %}


{% block content %}
<div class="row">
    <div class="col-md-6">
    <figure>
    <svg id="proposals-main" class='canvas' width="100%" height="440" />        
    <figcaption>Figure caption tag here</figcaption>
    </figure>
    </div>
    <div class="col-md-6">
    <figure>
    <svg id="proposals-detail" class='canvas' width="100%" height="440" />        
    <figcaption>Figure caption tag here</figcaption>
    </figure>
    </div>    
</div> 
{% endblock %}

{% block scripts %}{{ super() }}

    <script type="text/javascript">
function prop(p) {
  return function(d) {
    return d[p];
  };
}

PARTIES = [
    {
        name: "m",
        color: "#1b49dd"
    },
    {
        name: "fp",
        color: "#6bb7ec"
    },
    {
        name: "kd",
        color: "#231977"
    },
    {
        name: "c",
        color: "#009933"
    },
    {
        name: "sd",
        color: "#dddd00"
    },
    {
        name: "mp",
        color: "#83cf39"
    },
    {
        name: "s",
        color: "#ee2020"
    },
    {
        name: "v",
        color: "#af0000"
    },
    {
        name: "fi",
        color: "#d9308e"
    },
    {
        name: "nyd",
        color: "#dddd00"
    }
    ];
var COLORS = PARTIES.concat([
    { name: "alla enskilda motioner", color: "#7f7f7f"},
    { name: "bifall", color: "#2ca02c" },
    { name: "delvis bifall", color: "#ff7f0e" },
    { name: "avslag", color: "#d62728" }
  ]);
COLORS = d3.map(COLORS, function(d){return d.name;});

sankey_data = {{data | tojson | safe}};


proposals_main = function() {

  var width, height;
  var onNodeSelected, onNodeDeselected;

  var node_yspacing = 3,
      node_group_yspacing = 0;

  var node_group_ypadding = 10;

  var node_group_width = 30+40;
  var node_width = 30;

  var group_label_distance = 5;

  var flow_start_width = 20;

  function sankey(selection){
    selection.each(function(data){

      var yscale;
      
      var currently_active = null;

      compute_positions = function() {
        node_layers = data.nodes;

        node_layers.forEach(function(layer, layer_idx){
          var y = 0.5*(height-layer.total_height);
          layer.y = y;
          layer.items.forEach(function(group, group_idx){

            group.x = (width-node_group_width)*layer.x;
            group.y = y;
            y += node_group_ypadding;

            group.items.forEach(function(node, node_idx){
              node.x = group.x + 0.5*(node_group_width-node_width);
              node.y = y;
              y += node.size * yscale;
              node.height = y - node.y;
              y += node_yspacing;

              node.layer_idx = layer_idx;
              node.group_idx = group_idx;
              node.node_idx = node_idx;
              node.unique_id = [layer_idx, group_idx, node_idx].join("-");

              var colorobj = COLORS.get( (""+node.title).toLowerCase() );
              node.color = d3.hsl(colorobj ? colorobj.color : '#7f7f7f'); 
            });

            y -= node_yspacing;
            y += node_group_ypadding;
            group.height = y - group.y;
            
            y += node_group_yspacing;

          });
          y -= node_group_yspacing;
        });
      };

      compute_sizes = function() {

        var nodes = data.nodes;
        var flows = data.flows;

        // compute and store sizes of all layers, groups and nodes by counting flows through them
        flows.forEach(function(flow){
          flow.path.forEach(function(p) {
            layer = nodes[p[0]];
            node_group = layer.items[p[1]];
            node = node_group.items[p[2]];
            layer.size = layer.size + flow.magnitude || flow.magnitude;
            node_group.size = node_group.size + flow.magnitude || flow.magnitude;
            node.size = node.size + flow.magnitude || flow.magnitude;
          });
        });

        
        nodes.forEach(function(layer){
          layer.num_node_spacings = d3.sum(layer.items, function(g){return g.items.length-1;});
          layer.num_group_spacings = layer.items.length-1;
        });

        // yscale calibrated to fill height after equation:
        // height == size*yscale + group_spacing + group_padding + node_spacing
        // (take worst case: smallest value)
        yscale = d3.min(nodes, function(d){
          return (height 
                  - d.num_group_spacings*node_group_yspacing
                  - d.items.length*node_group_ypadding*2
                  - d.num_node_spacings*node_yspacing)/d.size;
        });

        nodes.forEach(function(layer){
          layer.total_height = layer.size * yscale
                              + layer.num_group_spacings*node_group_yspacing
                              + layer.items.length*node_group_ypadding*2
                              + layer.num_node_spacings*node_yspacing;
        });


      };

      compute_flow_areas = function() {

        var nodes = data.nodes;
        var flows = data.flows; // copy so we can destroy it
        
        flows.forEach(function(flow){
          flow.extra_classes = flow.path.map(function(addr){return "passes-"+addr.join("-");}).join(" ");
        });

        while(true) {

          flows = flows.filter(function(d){return d.path.length > 1});
          if (flows.length == 0) return;

          flows.sort(function(a,b){
            return   a.path[0][0]-b.path[0][0] 
                  || a.path[0][1]-b.path[0][1] 
                  || a.path[0][2]-b.path[0][2]
                  || a.path[1][0]-b.path[1][0] 
                  || a.path[1][1]-b.path[1][1] 
                  || a.path[1][2]-b.path[1][2];
          });

          var layer_idx = flows[0].path[0][0];
          flows.forEach(function(flow){

            if (flow.path[0][0] != layer_idx) return;
            var from = flow.path[0];
            var to = flow.path[1];
            var h = flow.magnitude*yscale;

            var source = nodes[from[0]].items[from[1]].items[from[2]];
            var target = nodes[to[0]].items[to[1]].items[to[2]];

            var source_y0 = source.filled_out_y || source.y;
            var source_y1 = source_y0 + h;
            source.filled_out_y = source_y1;
            var target_y0 = target.filled_in_y || target.y;
            var target_y1 = target_y0 + h;
            target.filled_in_y = target_y1;

            flow_area_data.push({
              area: [
                      {x: source.x+node_width, y0: source_y0, y1: source_y1},
                      {x: source.x+node_width+flow_start_width, y0: source_y0, y1: source_y1},
                      {x: target.x-flow_start_width, y0: target_y0, y1: target_y1},
                      {x: target.x, y0: target_y0, y1: target_y1},
                    ],
              class: ["flow", flow.extra_classes].join(" ")
              });

            flow.path.shift();
          });
        }        

      };

      var flow_area_data = [];

      compute_sizes();
      compute_positions();
      compute_flow_areas();

      var total_size = data.nodes[0].size;

      var parent = d3.select(this);

      var node_layers = parent.selectAll(".node-layers")
                            .data(prop("nodes"));
      node_layers.enter()
                  .append("g").classed("node-layer",true);

      var node_groups = node_layers.selectAll(".node-group")
                                    .data(prop("items"));
      node_groups.enter()
                  .append("g").classed("node-group", true);

      node_groups.append("rect")
            .classed("node-group", true)
            .attr("x", prop("x"))
            .attr("y", prop("y"))
            .attr("width", node_group_width)
            .attr("height", prop("height"));

      ng_labelx = function(d){return d.x+0.5*node_group_width+0.5*d.label*node_width;}
      ng_labely = function(d){return d.y + 0.5*d.height;}


      tip = d3.tip().attr('class', 'd3-tip')
      .direction('e')
      .html(function(d) { return d.title; });

      selection.call(tip)
      
      var group_labels = node_groups.append("g")
        .style("display",function(d){return d.label ? "" : "none";})
        .attr("class","node-group-label");
      group_labels.append("text")
        .text(function(d){return (100*d.size/total_size).toFixed(0)+ "%";})
        .attr("text-anchor","middle")
        .attr("dy",function(d){return d.label*.7+"em";})
        .attr("transform",function(d){return "rotate(-90,"+ng_labelx(d)+","+ng_labely(d)+")";})
        .attr("x", ng_labelx)
        .attr("y", ng_labely);
      group_labels.append("path")
        .attr("d", function(d){
          return d3.svg.line()([
            [ng_labelx(d)+group_label_distance*d.label ,d.y+node_group_ypadding],
            [ng_labelx(d)+group_label_distance*d.label ,d.y+d.height-node_group_ypadding]
            ]);});
      group_labels.append("rect")
        .attr('class', 'click-capture')
        .style('visibility', 'hidden')
        .attr('x', function(d){return d.x;})
        .attr('y', function(d){return d.y;})
        .attr('width', 0.5*(node_group_width-node_width))
        .attr('height', prop("height"))        
        .on('mouseover', tip.show)
        .on('mouseout', tip.hide);

      var flows_elements = parent.selectAll(".flow").data(flow_area_data)
        .enter()
          .append("path")
          .attr("class", prop("class"))
          .datum(prop("area"))
          .attr("d", 
            d3.svg.area()
              .x(prop("x"))
              .y0(prop("y0"))
              .y1(prop("y1"))
              .interpolate("basis"));

      var nodes_elements = node_groups.selectAll(".node")
                          .data(prop("items"));
      nodes_elements.enter()
            .append("g").attr("class", "node");
      nodes_elements.append("rect")
            .attr("class", function(d){return "node-"+d.unique_id;})
            .attr("x", prop("x"))
            .attr("y", prop("y"))
            .attr("width", node_width)
            .attr("height",prop("height"))
            .style("fill", function(d){return d.color;})
            .on("mouseover", function(d){
              d3.select(this).transition().style("fill", d.color.brighter());
            })
            .on("mouseout", function(d){
              d3.select(this).transition().style("fill", d.color);
            })
            .on("click", function(d,i){
              
              var node_id = d.unique_id;

              if (currently_active) {
                var theflows = parent.selectAll(".passes-"+currently_active.id);
                var thenode = parent.selectAll(".node-"+currently_active.id);

                if (onNodeDeselected) onNodeDeselected(currently_active.d);

                theflows.transition()
                  .style("fill", null)
                  .style("fill-opacity", null);


                 if (currently_active.id == node_id) {
                   currently_active = null;
                   return;
                 }
              }

              theflows = parent.selectAll(".passes-"+node_id);
              thenode = parent.selectAll(".node-"+node_id);

              if (onNodeSelected) onNodeSelected(d);

              theflows.transition()
                .style("fill", d.color)
                .style("fill-opacity", 1.0);

              currently_active = {"id": node_id, "d": d};
              
            });          
    }); // selection.each()
  };
  
  sankey.width = function(_) {
    if (!arguments.length) return width;
    else width = +_;
    return sankey;
  }
  sankey.height = function(_) {
    if (!arguments.length) return height;
    else height = +_;
    return sankey;
  }    
  sankey.onNodeSelected = function(_) {
    if (!arguments.length) return onNodeSelected;
    else onNodeSelected = _;
    return sankey;
  }   
  sankey.onNodeDeselected = function(_) {
    if (!arguments.length) return onNodeDeselected;
    else onNodeDeselected = _;
    return sankey;
  }    

  return sankey;
};

function party_detail() {

  function chart(selection) {
    selection.each(function(data) {

      return;
    }); // selection.each
  };
  return chart;
}


$(d3.select("#proposals-main").datum(sankey_data).call(
  proposals_main()
    .width(450)
    .height(440)
    .onNodeSelected(function(d){console.log("Selected " + d.title);})
    .onNodeDeselected(function(d){console.log("Deselected " + d.title);})
  ));   

    </script>
{%- endblock %}