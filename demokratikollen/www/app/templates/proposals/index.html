{% extends "proposals/base.html" %}

{% block styles -%}{{ super() }}
    <style>
.canvas {
}

.node rect {
    fill: #aaa;
    stroke: none;
}
rect.node-group {
  display:none;
}
.flow {
  fill: #000;
  fill-opacity: .2;
  stroke: 0px;
  stroke-opacity: .2;
}

.flow:hover {
  stroke-opacity: .5;
  fill-opacity:.5;
}


    </style>

{%- endblock %}


{% block content %}
<div class="row">
    <div class="col-lg-1"></div>
    <div class="col-lg-10">
    <svg id="proposals-main" class='canvas' viewBox='0 0 940 440' preserveAspectRatio="xMinYMin meet"/>        
    </div>
</div> 
{% endblock %}

{% block scripts %}{{ super() }}
    <script type="text/javascript">

sankey_data = {{data | tojson | safe}};

function prop(p) {

  return function(d) {
    return d[p];
  };

}
proposals_main = function() {

  var width, height;

  var node_yspacing = 3,
      node_group_yspacing = 0;

  var node_group_ypadding = 10;

  var node_group_width = 30+10;
  var node_width = 30;

  var flow_start_width = 20;

  function sankey(selection){
    selection.each(function(data){

      var yscale;
      
      var currently_active = null;

      compute_positions = function() {
        node_layers = data.nodes;

        node_layers.forEach(function(layer, layer_idx){
          var y = 0.5*(height-layer.total_height);
          layer.y = y;
          layer.items.forEach(function(group, group_idx){

            group.x = (width-node_group_width)*layer.x;
            group.y = y;
            y += node_group_ypadding;

            group.items.forEach(function(node, node_idx){
              node.x = group.x + 0.5*(node_group_width-node_width);
              node.y = y;
              y += node.size * yscale;
              node.height = y - node.y;
              y += node_yspacing;

              node.layer_idx = layer_idx;
              node.group_idx = group_idx;
              node.node_idx = node_idx;
              node.unique_id = [layer_idx, group_idx, node_idx].join("-");
            });

            y -= node_yspacing;
            y += node_group_ypadding;
            group.height = y - group.y;
            
            y += node_group_yspacing;

          });
          y -= node_group_yspacing;
        });
      };

      compute_sizes = function() {

        var nodes = data.nodes;
        var flows = data.flows;

        // compute and store sizes of all layers, groups and nodes by counting flows through them
        flows.forEach(function(flow){
          flow.path.forEach(function(p) {
            layer = nodes[p[0]];
            node_group = layer.items[p[1]];
            node = node_group.items[p[2]];
            layer.size = layer.size + flow.magnitude || flow.magnitude;
            node_group.size = node_group.size + flow.magnitude || flow.magnitude;
            node.size = node.size + flow.magnitude || flow.magnitude;
          });
        });

        
        nodes.forEach(function(layer){
          layer.num_node_spacings = d3.sum(layer.items, function(g){return g.items.length-1;});
          layer.num_group_spacings = layer.items.length-1;
        });

        // yscale calibrated to fill height after equation:
        // height == size*yscale + group_spacing + group_padding + node_spacing
        // (take worst case: smallest value)
        yscale = d3.min(nodes, function(d){
          return (height 
                  - d.num_group_spacings*node_group_yspacing
                  - d.items.length*node_group_ypadding*2
                  - d.num_node_spacings*node_yspacing)/d.size;
        });

        nodes.forEach(function(layer){
          layer.total_height = layer.size * yscale
                              + layer.num_group_spacings*node_group_yspacing
                              + layer.items.length*node_group_ypadding*2
                              + layer.num_node_spacings*node_yspacing;
        });


      };

      compute_flow_areas = function() {

        var nodes = data.nodes;
        var flows = data.flows; // copy so we can destroy it
        
        flows.forEach(function(flow){
          flow.extra_classes = flow.path.map(function(addr){return "passes-"+addr.join("-");}).join(" ");
        });

        while(true) {

          flows = flows.filter(function(d){return d.path.length > 1});
          if (flows.length == 0) return;

          flows.sort(function(a,b){
            return   a.path[0][0]-b.path[0][0] 
                  || a.path[0][1]-b.path[0][1] 
                  || a.path[0][2]-b.path[0][2]
                  || a.path[1][0]-b.path[1][0] 
                  || a.path[1][1]-b.path[1][1] 
                  || a.path[1][2]-b.path[1][2];
          });

          var layer_idx = flows[0].path[0][0];
          flows.forEach(function(flow){

            if (flow.path[0][0] != layer_idx) return;
            var from = flow.path[0];
            var to = flow.path[1];
            var h = flow.magnitude*yscale;

            var source = nodes[from[0]].items[from[1]].items[from[2]];
            var target = nodes[to[0]].items[to[1]].items[to[2]];

            var source_y0 = source.filled_out_y || source.y;
            var source_y1 = source_y0 + h;
            source.filled_out_y = source_y1;
            var target_y0 = target.filled_in_y || target.y;
            var target_y1 = target_y0 + h;
            target.filled_in_y = target_y1;

            flow_area_data.push({
              area: [
                      {x: source.x+node_width, y0: source_y0, y1: source_y1},
                      {x: source.x+node_width+flow_start_width, y0: source_y0, y1: source_y1},
                      {x: target.x-flow_start_width, y0: target_y0, y1: target_y1},
                      {x: target.x, y0: target_y0, y1: target_y1},
                    ],
              class: ["flow", flow.extra_classes].join(" ")
              });

            flow.path.shift();
          });
        }        

      };

      var flow_area_data = [];

      compute_sizes();
      compute_positions();
      compute_flow_areas();

      var parent = d3.select(this);

      var node_layers = parent.selectAll(".node-layers")
                            .data(prop("nodes"));
      node_layers.enter()
                  .append("g").classed("node-layer",true);

      var node_groups = node_layers.selectAll(".node-group")
                                    .data(prop("items"));
      node_groups.enter()
                  .append("g").classed("node-group", true);

      node_groups.append("rect")
            .classed("node-group", true)
            .attr("x", prop("x"))
            .attr("y", prop("y"))
            .attr("width", node_group_width)
            .attr("height", prop("height"));

      var flows_elements = parent.selectAll(".flow").data(flow_area_data)
        .enter()
          .append("path")
          .attr("class", prop("class"))
          .datum(prop("area"))
          .attr("d", 
            d3.svg.area()
              .x(prop("x"))
              .y0(prop("y0"))
              .y1(prop("y1") )
              .interpolate("monotone"));

      var nodes_elements = node_groups.selectAll(".node")
                          .data(prop("items"));
      nodes_elements.enter()
            .append("g").attr("class", "node");
      nodes_elements.append("rect")
            .attr("class", function(d){return "node-"+d.unique_id;})
            .attr("x", prop("x"))
            .attr("y", prop("y"))
            .attr("width", node_width)
            .attr("height",prop("height"))
            .on("click", function(d,i){
              
              var node_id = d.unique_id;

              if (currently_active == node_id) return;

              if (currently_active) {
                var theflows = parent.selectAll(".passes-"+currently_active);
                var thenode = parent.selectAll(".node-"+currently_active);

                theflows.transition()
                  .style("fill", null)
                  .style("fill-opacity", null);
                thenode.transition()
                  .style("fill", null)
                  .style("fill-opacity", null);

                 currently_active = null;
              }

              var theflows = parent.selectAll(".passes-"+node_id);
              var thenode = parent.selectAll(".node-"+node_id);
              console.log(node_id);
              theflows.transition()
                .style("fill", "#ff0000")
                .style("fill-opacity", 1.0);
              thenode.transition()
                .style("fill", "#ff0000")
                .style("fill-opacity", 1.0);


              currently_active = node_id;
              
            });          

    }); // selection.each()
  };
  
  sankey.width = function(_) {
    if (!arguments.length) return width;
    else width = +_;
    return sankey;
  }
  sankey.height = function(_) {
    if (!arguments.length) return height;
    else height = +_;
    return sankey;
  }    

  return sankey;
};

$(d3.select("#proposals-main").datum(sankey_data).call(
  proposals_main()
    .width(500)
    .height(440)
  )); 

    </script>
{%- endblock %}